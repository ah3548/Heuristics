// Generated by CoffeeScript 1.10.0
(function() {
  var HOST, MATCHMAKER_PORT, N, PLAYER_PORT, Utils, client, connectingPort, createBasicCandidate, lastReceivedNumbers, lastReceivedScore, makeCandidate, net, utilsL;

  console.log("In player Client");

  net = require('net');

  Utils = require("./utils");

  this.utils = new Utils;

  utilsL = this.utils;

  N = this.utils.N;

  HOST = this.utils.HOST;

  MATCHMAKER_PORT = this.utils.MATCHMAKER_PORT;

  PLAYER_PORT = this.utils.PLAYER_PORT;

  lastReceivedNumbers = [];

  lastReceivedScore = 0;

  connectingPort = {
    port: PLAYER_PORT
  };

  var original = null;
  makeCandidate = function() {
    var basicCandidate = null;
    if (original == null) {
        basicCandidate = createTrickyCandidate();
        original = basicCandidate;
    }  
    else {
        basicCandidate = modifyTrickyCandidate();
    }
    return basicCandidate;
  };

  var numAllowed = N/10;
  modifyTrickyCandidate = function() {
      //var newCand = original;
      var mixAndMatch = [];
      for (var i = 0; i < original.length; i++) {
        var cand = {weight:original[i], pos:i};
        mixAndMatch.push(cand);
      }
      mixAndMatch.sort(function(a,b){return b.weight-a.weight;});
    
      var numSwapsLeft = N/10;
      var curSwap = 0;
      while (numSwapsLeft > 0) {
          var num1 = parseFloat(mixAndMatch[curSwap].weight);
          var num2 = parseFloat(mixAndMatch[curSwap+1].weight);
          if (num1 <= 0 || num2 <= 0) {
              break;
          }
          var diff = parseFloat((Math.random()*num2*0.4).toFixed(2));
          if (diff != 0) {
              console.log('diff');
              console.log(diff);
              num1-=diff;
              num2+=diff;
              mixAndMatch[curSwap].weight = num1.toFixed(2);
              mixAndMatch[curSwap+1].weight = num2.toFixed(2);
              numSwapsLeft--;
              curSwap+=2;
          }
          else {
            curSwap++;
          }
      }
      
      /*var newValues = [];
      for (var i = 0; i < original.length; i++) {
          if (original[i] > 0) {
              var bleed = Math.random()*(newCand[i]*.4);
              newCand[i]-=bleed;
          }
      }*/
      mixAndMatch.sort(function(a,b){return a.pos-b.pos;});
      var result = [];
      for (var i = 0; i < original.length; i++) {
        result.push(mixAndMatch[i].weight);
      }
      for (var i = 0; i < original.length; i++) {
        //console.log(original);
        //console.log(result);
      }
      return result;
  }
  
  createTrickyCandidate = function() {
      var tricky = [];
      tricky = tricky.concat(generatePosWeights());
      tricky = tricky.concat(generateNegWeights());
      for (var i = tricky.length; i < N; i++) {
          tricky.push(0);
      }
      return tricky;
  };
    
  generatePosWeights = function() {
      var weights = [];
      var numVariables = Math.floor(N/2)-1;
      console.log('numVariables');
      console.log(numVariables);
      var total = 1;
      for (var i = 0; i < numVariables; i++) {
          var curNum = (Math.random()/numVariables).toFixed(2);
          total-=curNum;
          weights.push(curNum);
      }
      weights.push(total.toFixed(2));
      return weights;
  };
    
  generateNegWeights = function() {
      var weights = [];
      var numVariables = Math.floor(N/2)-1;
      var total = 1;
      for (var i = 0; i < numVariables; i++) {
          var curNum = (Math.random() * 1/numVariables).toFixed(2);
          total-=curNum;
          weights.push(-curNum);
      }
      weights.push(-total.toFixed(2));
      return weights;
  };

  createBasicCandidate = function() {
    var candidate, i, index, ref, weightValue;
    candidate = [];
    weightValue = 1 / (N / 2);
    for (index = i = 1, ref = N; 1 <= ref ? i <= ref : i >= ref; index = 1 <= ref ? ++i : --i) {
      if (index % 2 === 0) {
        candidate.push(weightValue);
      } else {
        candidate.push(-weightValue);
      }
    }
    return candidate;
  };

  client = net.connect(connectingPort, function() {
    var candidate, candidateString;
    console.log("Player client connected on port " + connectingPort.port);
    candidate = makeCandidate();
    candidateString = utilsL.convertNumArrayToFormattedString(candidate);
    return client.write(candidateString);
  });

  client.on('data', function(data) {
    var candidate, candidateString;
    data = data.toString();
    if (data !== "gameover") {
      candidate = makeCandidate();
      candidateString = utilsL.convertNumArrayToFormattedString(candidate);
      console.log("Player Client sending data");
      return client.write(candidateString);
    } else {
      return console.log("GAMEOVER");
    }
  });

}).call(this);
